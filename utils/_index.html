<html>
	<head>
		<title>Miloje's code diary</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@600&family=Play:wght@400;700&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="style.css">
	</head>

	<body>
		<div class="content">
			<h1>Code Archive</h1>

<h2>sorting algorithams'</h2>
<h3>heap sort</h3>
<pre><code>
#include&#x3C;stdio.h&#x3E;
#define MAX 10

void swap( int&#x26; a, int&#x26; b )
{
&#x9;int temp = a;
&#x9;a = b;
&#x9;b = temp;
}

void heapify( int A[], int n, int parent )
{
&#x9;int left = 2 * parent;
&#x9;int right = left + 1;
&#x9;int largest = parent;

&#x9;if( left &#x3C; n &#x26;&#x26; A[left] &#x3E; A[largest] )
&#x9;{
&#x9;&#x9;largest = left;
&#x9;}

&#x9;if( right &#x3C; n &#x26;&#x26; A[right] &#x3E; A[largest] )
&#x9;{
&#x9;&#x9;largest = right;
&#x9;}

&#x9;if(parent != largest)
&#x9;{
&#x9;&#x9;swap(A[parent], A[largest]);
&#x9;&#x9;heapify( A, n, largest );
&#x9;}
}

void sort( int A[], int n )
{
&#x9;for( int i = n / 2; i &#x3E;= 0; i -- )
&#x9;{
&#x9;&#x9;heapify( A, n, i );
&#x9;}

&#x9;for( int i = n - 1; i &#x3E; 0; i -- )
&#x9;{
&#x9;&#x9;swap( A[0], A[i] );
&#x9;&#x9;heapify( A, i, 0 );
&#x9;}
}

int main()
{
&#x9;while(1)
&#x9;{
&#x9;&#x9;printf( &#x22Unesi duzinu niza:\n&#x22 );
&#x9;&#x9;int n;
&#x9;&#x9;scanf( &#x22%d&#x22, &#x26;n );

&#x9;&#x9;int A[MAX];
&#x9;&#x9;printf( &#x22Unesi niz:\n&#x22 );
&#x9;&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;scanf( &#x22%d&#x22, &#x26;A[i] );
&#x9;&#x9;}

&#x9;&#x9;sort( A, n );

&#x9;&#x9;printf( &#x22Soritrani niz:\n&#x22 );
&#x9;&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;printf( &#x22%d &#x22, A[i] );
&#x9;&#x9;}

&#x9;&#x9;printf( &#x22\n&#x22 );
&#x9;}
}
</pre></code>
<h3>selection</h3>
<pre><code>
#include&#x3C;stdio.h&#x3E;
#define MAX 10
void sort( int a[], int n )
{
&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;int max = a[i], i_max = i;
&#x9;&#x9;for( int j = i + 1; j &#x3C; n; j ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;if( a[j] &#x3E; max )
&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;max = a[j];
&#x9;&#x9;&#x9;&#x9;i_max = j;
&#x9;&#x9;&#x9;}
&#x9;&#x9;}
&#x9;&#x9;a[i_max] = a[i];
&#x9;&#x9;a[i] = max;
&#x9;}
}

int main()
{
&#x9;int a[MAX], n;
&#x9;scanf( &#x22%d&#x22, &#x26;n );

&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;scanf( &#x22%d&#x22, &#x26;a[i] );
&#x9;}

&#x9;sort( a, n );

&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;printf( &#x22%d &#x22, a[i] );
&#x9;}
}
</pre></code>
<h3>insertion</h3>
<pre><code>
#include&#x3C;stdio.h&#x3E;
#define MAX 10

void sort( int a[], int n )
{
&#x9;for( int i = 1; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;int key = a[i];
&#x9;&#x9;int j = i - 1;
&#x9;&#x9;while( j &#x3E;= 0 &#x26;&#x26; a[j] &#x3E; key )
&#x9;&#x9;{
&#x9;&#x9;&#x9;a[j + 1] = a[j];
&#x9;&#x9;&#x9;j --;
&#x9;&#x9;}
&#x9;&#x9;a[j + 1] = key;
&#x9;}
}

int main()
{
&#x9;int a[ MAX ];
&#x9;int n;
&#x9;scanf( &#x22%d&#x22, &#x26;n );
&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;scanf( &#x22%d&#x22, &#x26;a[i] );
&#x9;}

&#x9;sort( a, n );

&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;printf( &#x22%d &#x22, a[i] );
&#x9;}
}
</pre></code>
<h3>merge</h3>
<pre><code>
#include&#x3C;stdio.h&#x3E;
#include&#x3C;limits.h&#x3E;
#define MAX 10

void _merge( int a[], int start, int mid, int end )
{
&#x9;int A[MAX], B[MAX];
&#x9;int n_a = mid - start + 1;
&#x9;int n_b = end - mid;

&#x9;for( int i = 0; i &#x3C; n_a; i ++ )
&#x9;{
&#x9;&#x9;A[i] = a[start + i];
&#x9;}
&#x9;for( int i = 0; i &#x3C; n_b; i ++ )
&#x9;{
&#x9;&#x9;B[i] = a[mid + 1 + i];
&#x9;}

&#x9;int i_a = 0, i_b = 0;
&#x9;int is_a_empty = 0;
&#x9;int is_b_empty = 0;
&#x9;for( int i = start; i &#x3C;= end; i ++ )
&#x9;{

&#x9;&#x9;if( is_a_empty )
&#x9;&#x9;{
&#x9;&#x9;&#x9;a[i] = B[i_b];
&#x9;&#x9;&#x9;i_b ++;
&#x9;&#x9;}
&#x9;&#x9;else if( is_b_empty )
&#x9;&#x9;{
&#x9;&#x9;&#x9;a[i] = A[i_a];
&#x9;&#x9;&#x9;i_a ++;
&#x9;&#x9;}
&#x9;&#x9;else
&#x9;&#x9;{
&#x9;&#x9;&#x9;if( A[i_b] &#x3E;= B[i_b] )
&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;a[i] = A[i_a];
&#x9;&#x9;&#x9;&#x9;i_a ++;
&#x9;&#x9;&#x9;&#x9;is_a_empty = i_a == n_a;
&#x9;&#x9;&#x9;}
&#x9;&#x9;&#x9;else
&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;a[i] = B[i_b];
&#x9;&#x9;&#x9;&#x9;i_b ++;
&#x9;&#x9;&#x9;&#x9;is_b_empty = i_b == n_b;
&#x9;&#x9;&#x9;}
&#x9;&#x9;}
&#x9;}
}

void merge( int a[], int start, int mid, int end )
{

&#x9;int A[MAX], B[MAX];
&#x9;int n1 = mid - start + 1;
&#x9;int n2 = end - mid;

&#x9;for( int i = 0; i &#x3C; n1; i ++ )
&#x9;{
&#x9;&#x9;A[i] = a[start + i];
&#x9;}
&#x9;for( int i = 0; i &#x3C; n2; i ++ )
&#x9;{
&#x9;&#x9;B[i] = a[mid + 1 + i];
&#x9;}

&#x9;A[n1] = INT_MIN;
&#x9;B[n2] = INT_MIN;

&#x9;n1 = 0; n2 = 0;
&#x9;for( int i = start; i &#x3C;= end; i ++ )
&#x9;{
&#x9;&#x9;if( A[n1] &#x3E;= B[n2] )
&#x9;&#x9;{
&#x9;&#x9;&#x9;a[i] = A[n1];
&#x9;&#x9;&#x9;n1 ++;
&#x9;&#x9;}
&#x9;&#x9;else
&#x9;&#x9;{
&#x9;&#x9;&#x9;a[i] = B[n2];
&#x9;&#x9;&#x9;n2 ++;
&#x9;&#x9;}
&#x9;}
}

void sort( int a[], int start, int end )
{
&#x9;if( end &#x3E; start )
&#x9;{
&#x9;&#x9;int mid = start + (end - start) / 2;
&#x9;&#x9;sort( a, start, mid );
&#x9;&#x9;sort( a, mid + 1, end );
&#x9;&#x9;_merge(a, start, mid, end );
&#x9;}
}

int main()
{
&#x9;int n, a[MAX];
&#x9;scanf( &#x22%d&#x22, &#x26;n );

&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;scanf( &#x22%d&#x22, &#x26;a[i] );
&#x9;}

&#x9;sort( a, 0, n - 1 );

&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;{
&#x9;&#x9;printf( &#x22%d &#x22, a[i] );
&#x9;}
}
</pre></code>
<h3>html encode</h3>
<pre><code>
#include&#x3C;stdio.h&#x3E;
#include&#x3C;string.h&#x3E;
#define MAX_LEN 100

int main( int file_count, char** file_names)
{
&#x9;for( int i = 0; i &#x3C; file_count; i ++ )
&#x9;{
&#x9;&#x9;FILE *code, *encoded;
&#x9;&#x9;char c;

&#x9;&#x9;int name_len = strlen( file_names[ i ] );
&#x9;&#x9;if( file_names[ i ][ name_len - 2 ] == &#x27;.&#x27; &#x26;&#x26; file_names[ i ][ name_len - 1 ] == &#x27;c&#x27; )
&#x9;&#x9;{
&#x9;&#x9;&#x9;code = fopen( file_names[ i ], &#x22r&#x22 );

&#x9;&#x9;&#x9;char output_fname[ MAX_LEN ];
&#x9;&#x9;&#x9;output_fname[ 0 ] = &#x27;\0&#x27;;

&#x9;&#x9;&#x9;strcat( output_fname, file_names[ i ] );
&#x9;&#x9;&#x9;output_fname[ name_len - 2 ] = &#x27;\0&#x27;;
&#x9;&#x9;&#x9;strcat( output_fname, &#x22.html_encoded&#x22 );

&#x9;&#x9;&#x9;encoded = fopen( output_fname, &#x22w&#x22 );

&#x9;&#x9;&#x9;while( ( c = getc( code ) ) != EOF )
&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;switch( c )
&#x9;&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;&#x9;case &#x27;&#x3C;&#x27;:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fputs( &#x22&#x26;#x3C;&#x22, encoded );
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;
&#x9;&#x9;&#x9;&#x9;&#x9;case &#x27;&#x3E;&#x27;:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fputs( &#x22&#x26;#x3E;&#x22, encoded );
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;
&#x9;&#x9;&#x9;&#x9;&#x9;case &#x27;&#x22&#x27;:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fputs( &#x22&#x26;#x22&#x22, encoded );
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;
&#x9;&#x9;&#x9;&#x9;&#x9;case &#x27;\&#x27;&#x27;:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fputs( &#x22&#x26;#x27;&#x22, encoded );
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;
&#x9;&#x9;&#x9;&#x9;&#x9;case &#x27;&#x26;&#x27;:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fputs( &#x22&#x26;#x26;&#x22, encoded );
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;
&#x9;&#x9;&#x9;&#x9;&#x9;case &#x27;\t&#x27;:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fputs( &#x22&#x26;#x9;&#x22, encoded );
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;
&#x9;&#x9;&#x9;&#x9;&#x9;default:
&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;putc( c, encoded );
&#x9;&#x9;&#x9;&#x9;}
&#x9;&#x9;&#x9;}
&#x9;&#x9;}
&#x9;}
}
</pre></code>
<h2>graph algorithams›M</h2>
<h3>dfs</h3>
<pre><code>
#include &#x3C;stdio.h&#x3E;
#include &#x3C;string.h&#x3E;
#define NN 1024
#define CLR( x ) memset( x, 0, sizeof( x ) )

int adj[ NN ][ NN ], deg[ NN ], visited[ NN ];

void dfs( int current )
{
&#x9;if( visited[ current ] )
&#x9;{
&#x9;&#x9;return;
&#x9;}

&#x9;visited[ current ] = 1;
&#x9;for( int i = 0; i &#x3C; deg[ current ]; i ++ )
&#x9;{
&#x9;&#x9;dfs( adj[ current ][ i ] );
&#x9;}
}

int main()
{
&#x9;int V, E;

&#x9;printf( &#x22input number of vertecies -&#x3E; &#x22 );
&#x9;scanf( &#x22%d&#x22, &#x26;V);

&#x9;printf( &#x22input number of edges -&#x3E; &#x22 );
&#x9;scanf( &#x22%d&#x22, &#x26;E);

&#x9;CLR( deg ); CLR( adj ); CLR( visited );

&#x9;for( int i = 0; i &#x3C; E; i ++ )
&#x9;{
&#x9;&#x9;int u, v;
&#x9;&#x9;printf( &#x22input edge -&#x3E; &#x22 );
&#x9;&#x9;scanf( &#x22%d%d&#x22, &#x26;u, &#x26;v );

&#x9;&#x9;adj[ u ][ deg[ u ] ++ ] = v;
&#x9;&#x9;adj[ v ][ deg[ v ] ++ ] = u;
&#x9;}

&#x9;int start;

&#x9;printf( &#x22input start node -&#x3E; &#x22 );
&#x9;scanf( &#x22%d&#x22, &#x26;start );

&#x9;dfs( start );

&#x9;printf( &#x22|%15s|%15s|\n&#x22, &#x22vertex&#x22, &#x22visited&#x22 );
&#x9;for( int i = 0; i &#x3C; V; i ++ )
&#x9;{
&#x9;&#x9;printf( &#x22|%15d|%15d|\n&#x22, i, visited[ i ] );
&#x9;}
}
</pre></code>
<h3>bfs</h3>
<pre><code>
#include &#x3C;stdio.h&#x3E;
#include &#x3C;string.h&#x3E;
#define CLR( x, v ) memset( x, v, sizeof( x ) )
#define NN 1024

int adj[ NN ][ NN ], deg[ NN ], pred[ NN ], queue[ NN ], in_queue[ NN ], path[ NN ];

void solve( int start )
{
&#x9;CLR( in_queue, 0 ); CLR( queue, -1 ); CLR( pred, -1 );

&#x9;queue[ 0 ] = start;
&#x9;in_queue[ start ] = 1;

&#x9;int at = 0, top = 1, current;

&#x9;while( ( current = queue[ at ] ) != -1 )
&#x9;{
&#x9;&#x9;for( int j = 0; j &#x3C; deg[ current ]; j ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;int neighbour = adj[ current ][ j ];
&#x9;&#x9;&#x9;if( !in_queue[ neighbour ] )
&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;pred[ neighbour ] = current;
&#x9;&#x9;&#x9;&#x9;queue[ top ] = neighbour;
&#x9;&#x9;&#x9;&#x9;in_queue[ neighbour ] = 1;
&#x9;&#x9;&#x9;&#x9;top ++;
&#x9;&#x9;&#x9;}
&#x9;&#x9;}
&#x9;&#x9;at ++;
&#x9;}
}

void reconstruct_path( int start, int end )
{
&#x9;if( pred[ end ] == -1 )
&#x9;{
&#x9;&#x9;printf( &#x22No path from %d to %d.\n&#x22, start, end );
&#x9;&#x9;return;
&#x9;}

&#x9;int len = 0;
&#x9;int next;
&#x9;path[ len ] = end;

&#x9;do
&#x9;{
&#x9;&#x9;next = pred[ path[ len ++ ] ];
&#x9;&#x9;path[ len ] = next;
&#x9;}
&#x9;while( next != start );

&#x9;printf( &#x22Path form %d to %d === &#x22, start, end );
&#x9;printf( &#x22%d&#x22, start );
&#x9;for( int i = len - 1; i &#x3E;= 0; i -- )
&#x9;{
&#x9;&#x9;printf( &#x22 -&#x3E; %d&#x22, path[ i ] );
&#x9;}
&#x9;printf( &#x22\n&#x22 );
}

void bfs( int start , int end)
{
&#x9;solve( start );
&#x9;reconstruct_path( start, end );
}

int main()
{
&#x9;int V, E;
&#x9;printf( &#x22Input number of vertices and edges -&#x3E; &#x22 );
&#x9;scanf( &#x22%d%d&#x22, &#x26;V, &#x26;E );

&#x9;for( int i = 0; i &#x3C; E; i ++ )
&#x9;{
&#x9;&#x9;int u, v;

&#x9;&#x9;printf( &#x22Input an edge -&#x3E; &#x22 );
&#x9;&#x9;scanf( &#x22%d%d&#x22, &#x26;u, &#x26;v );

&#x9;&#x9;adj[ u ][ deg[ u ] ++ ] = v;
&#x9;&#x9;adj[ v ][ deg[ v ] ++ ] = u;
&#x9;}

&#x9;int start, end;
&#x9;printf( &#x22Input start and end -&#x3E; &#x22 );
&#x9;scanf( &#x22%d%d&#x22, &#x26;start, &#x26;end );

&#x9;bfs( start, end );
}
</pre></code>
<h3>dijkstras</h3>
<pre><code>
#include &#x3C;stdio.h&#x3E;
#include &#x3C;string.h&#x3E;
#include &#x3C;limits.h&#x3E;
#define NN 1024
#define INF INT_MAX
#define CLR( x, v ) memset( x, v, sizeof( x ) )

int graph[ NN ][ NN ], adj[ NN ][ NN ], deg[ NN ];
int visited[ NN ], dist[ NN ], pre[ NN ];

int dijkstras( int n, int s, int f )
{
&#x9;CLR( visited, 0 );
&#x9;CLR( dist, -1 );
&#x9;CLR( pre, -1 );

&#x9;visited[ s ] = 1;
&#x9;dist[ s ] = 0;
&#x9;pre[ s ] = s;

&#x9;int current_node = s;
&#x9;int done = 0;
&#x9;while( !done )
&#x9;{
&#x9;&#x9;int min_dist = INF;
&#x9;&#x9;int next_node = current_node;

&#x9;&#x9;for( int i = 0; i &#x3C; deg[ current_node ]; i ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;if( !visited[ adj[ current_node ][ i ] ] )
&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;if( graph[ current_node ][ adj[ current_node ][ i ] ] &#x3C; min_dist )
&#x9;&#x9;&#x9;&#x9;{
&#x9;&#x9;&#x9;&#x9;&#x9;min_dist = graph[ current_node ][ adj[ current_node ][ i ] ];
&#x9;&#x9;&#x9;&#x9;&#x9;next_node = adj[ current_node ][ i ];
&#x9;&#x9;&#x9;&#x9;}
&#x9;&#x9;&#x9;}
&#x9;&#x9;}

&#x9;&#x9;if( next_node == current_node )
&#x9;&#x9;{
&#x9;&#x9;&#x9;break;
&#x9;&#x9;}

&#x9;&#x9;dist[ next_node ] = dist[ current_node ] + graph[ current_node ][ next_node ];
&#x9;&#x9;pre[ next_node ] = current_node;
&#x9;&#x9;visited[ next_node ] = 1;
&#x9;&#x9;current_node = next_node;

&#x9;&#x9;done = 1;
&#x9;&#x9;for( int i = 0; i &#x3C; n; i ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;done &#x26;= visited[ i ];
&#x9;&#x9;}

&#x9;}

&#x9;return dist[ f ];
}

int main()
{
&#x9;int V, E;
&#x9;while( scanf( &#x22%d%d&#x22, &#x26;V, &#x26;E ) == 2 )
&#x9;{
&#x9;&#x9;CLR( deg, 0 );
&#x9;&#x9;CLR( adj, -1 );

&#x9;&#x9;printf( &#x22insert edges -&#x3E;\n&#x22 );
&#x9;&#x9;for( int i = 0; i &#x3C; E; i ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;int u, v, w;
&#x9;&#x9;&#x9;scanf( &#x22%d%d%d&#x22, &#x26;u, &#x26;v, &#x26;w );

&#x9;&#x9;&#x9;graph[ u ][ v ] = w;
&#x9;&#x9;&#x9;adj[ u ][ deg[ u ] ++ ] = v;
&#x9;&#x9;}

&#x9;&#x9;int s, f;
&#x9;&#x9;printf( &#x22insert start &#x26; finish -&#x3E;\n&#x22 );
&#x9;&#x9;scanf( &#x22%d%d&#x22, &#x26;s, &#x26;f );

&#x9;&#x9;printf( &#x22delta( %d, %d ) -&#x3E; %d\n&#x22, s, f, dijkstras( V, s, f ) );
&#x9;&#x9;printf( &#x22|%15s|%15s|%15s|\n&#x22, &#x22vertex&#x22, &#x22predecesor&#x22, &#x22delta&#x22 );
&#x9;&#x9;for( int i = 0; i &#x3C; V; i ++ )
&#x9;&#x9;{
&#x9;&#x9;&#x9;printf( &#x22|%15d|%15d|%15d|\n&#x22, i, pre[ i ], dist[ i ] );
&#x9;&#x9;}
&#x9;}
}
</pre></code>

		</div>
	</body>
</html>
